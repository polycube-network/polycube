/**
* iptables API
* iptables API generated from iptables.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/polycube-network/swagger-codegen.git
* branch polycube
*/

/* Do not edit this file manually */

#include "api/IptablesApiImpl.h"
#define MANAGER_TYPE io::swagger::server::api::IptablesApiImpl
#define SERVICE_DESCRIPTION "Iptables-clone Service"
#define SERVICE_VERSION "1.0.0"
#define SERVICE_PYANG_GIT "polycube-new-code-restconf/6f1f7d4"
#define SERVICE_SWAGGER_CODEGEN_GIT "new_code_generator/1ca045d"
#define SERVICE_REQUIRED_KERNEL_VERSION ""
const std::string SERVICE_DATA_MODEL = R"POLYCUBE_DM(
module iptables {
	yang-version 1.1;
	namespace "http://polycube.network/iptables";
	prefix "iptables";

	import polycube-base { prefix "basemodel"; }

	organization "Polycube open source project";
	description "YANG data model for the Polycube iptables service";

	uses "basemodel:base-yang-module";

	extension cli-example {
		argument "value";
		description "A sample value used by the CLI generator";
	}

	typedef action {
		type enumeration {
			enum DROP;
			enum LOG;
			enum ACCEPT;
		}
		default DROP;
	}

	typedef conntrackstatus {
		type enumeration {
			enum NEW;
			enum ESTABLISHED;
			enum RELATED;
			enum INVALID;
		}
	}

	grouping rule-fields {

		leaf in-iface {
			type string;
			description "Name of the interface via which the packet is received";
			iptables:cli-example "eth0";
		}


		leaf out-iface {
			type string;
			description "Name of the interface via which the packet is going to be sent";
			iptables:cli-example "eth1";
		}

		leaf src {
			type string;
			description "Source IP Address.";
			iptables:cli-example "10.0.0.1/24";
		}

		leaf dst {
			type string;
			description "Destination IP Address.";
			iptables:cli-example "10.0.0.2/24";
		}

		leaf l4proto {
			type string;
			description "Level 4 Protocol.";
		}

		leaf sport {
			type uint16;
			description "Source L4 Port";
		}

		leaf dport {
			type uint16;
			description "Destination L4 Port";
		}

		leaf tcpflags {
			type string;
			description "TCP flags. Allowed values: SYN, FIN, ACK, RST, PSH, URG, CWR, ECE. ! means set to 0.";
			iptables:cli-example "!FIN,SYN,!RST,!ACK";
		}

		leaf conntrack {
			type conntrackstatus;
			description "Connection status (NEW, ESTABLISHED, RELATED, INVALID)";
		}

		leaf action {
			type action;
			description "Action if the rule matches. Default is DROP.";
			iptables:cli-example "DROP, ACCEPT, LOG";
		}
	}

	leaf interactive {
		type boolean;
		description "Interactive mode applies new rules immediately; if 'false', the command 'apply-rules' has to be used to apply all the rules at once. Default is TRUE.";
        default true;
	}

	leaf conntrack {
		type enumeration {
			enum ON;
			enum OFF;
		}
		description "Enables the Connection Tracking module. Mandatory if connection tracking rules are needed. Default is ON.";
	}

	list session-table {
		key "src dst l4proto sport dport";
		config false;
		leaf src {
			type string;
			config false;
			description "Source IP";
		}

		leaf dst {
			type string;
			config false;
			description "Destination IP";
		}

		leaf l4proto {
			type string;
			config false;
			description "Level 4 Protocol.";
		}


		leaf sport {
			type uint16;
			description "Source Port";
			config false;
		}

		leaf dport {
			type uint16;
			description "Destination";
			config false;
		}

		leaf state {
			type string;
			config false;
			description "Connection state.";
		}
	}

	list chain {
		key name;

		leaf name {
			type enumeration {
				enum INPUT;
				enum FORWARD;
				enum OUTPUT;
				enum INVALID;
			}
			description "Chain in which the rule will be inserted. Default: FORWARD.";
			iptables:cli-example "INPUT, FORWARD, OUTPUT.";
		}

		leaf default {
			type action;
			description "Default action if no rule matches in the ingress chain. Default is DROP.";
			iptables:cli-example "DROP, ACCEPT, LOG";
		}

		list stats {
			key "id";
			config false;
			leaf id {
				type uint32;
				config false;
				description "Rule Identifier";
			}

			leaf pkts {
				type uint64;
				description "Number of packets matching the rule";
				config false;
			}

			leaf bytes {
				type uint64;
				description "Number of bytes matching the rule";
				config false;
			}
		}

		list rule {
			key "id";
			leaf id {
				type uint32;
				description "Rule Identifier";
			}

			uses "iptables:rule-fields";
		}

		action append {
			input {
				uses "iptables:rule-fields";
			}
			output {
				leaf id {
					type uint32;
				}
			}
		}

		action insert {
			input {
				leaf id {
					type uint32;
				}
				uses "iptables:rule-fields";
			}
			output {
				leaf id {
					type uint32;
				}
			}
		}

		action delete {
			input {
				uses "iptables:rule-fields";
			}
		}

		action reset-counters{
			description "Reset the counters to 0 for the chain.";
			output{
				leaf result{
					type boolean;
					description "True if the operation is successful";
				}
			}
		}

		action apply-rules{
			description "Applies the rules when in batch mode (interactive==false)";
			output{
				leaf result{
					type boolean;
					description "True if the operation is successful";
				}
			}
		}

	}
}

)POLYCUBE_DM";
#include <polycube/services/shared_library.h>
