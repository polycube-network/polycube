/**
* bridge API
* bridge API generated from bridge.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
*/


/* Do not edit this file manually */



#include "PortsSchema.h"

namespace io {
namespace swagger {
namespace server {
namespace model {

PortsSchema::PortsSchema() {
    m_Status = "";
    m_StatusIsSet = false;
    m_Name = "";
    m_NameIsSet = false;
    m_Address = "";
    m_AddressIsSet = false;
    m_AccessIsSet = false;
    m_StpIsSet = false;
    m_Mode = "";
    m_ModeIsSet = false;
    m_TrunkIsSet = false;
    m_Peer = "";
    m_PeerIsSet = false;
    m_Uuid = "";
    m_UuidIsSet = false;

}

PortsSchema::~PortsSchema() {}

void PortsSchema::validate() {
    // TODO: implement validation
}

nlohmann::json PortsSchema::toJson() const {
    nlohmann::json val = nlohmann::json::object();

    if(m_StatusIsSet) {
        val["status"] = m_Status;
    }

    if(m_NameIsSet) {
        val["name"] = m_Name;
    }

    if(m_AddressIsSet) {
        val["address"] = m_Address;
    }

    if(m_AccessIsSet) {
        val["access"] = ModelBase::toJson(m_Access);
    }

    {
      nlohmann::json jsonArray;
      for (auto& item : m_Stp) {
        jsonArray.push_back(ModelBase::toJson(item));
      }

      if (jsonArray.size() > 0) {
        val["stp"] = jsonArray;
      }
    }
    if(m_ModeIsSet) {
        val["mode"] = m_Mode;
    }

    if(m_TrunkIsSet) {
        val["trunk"] = ModelBase::toJson(m_Trunk);
    }
    if(m_PeerIsSet) {
        val["peer"] = m_Peer;
    }

    if(m_UuidIsSet) {
        val["uuid"] = m_Uuid;
    }



    return val;
}

void PortsSchema::fromJson(nlohmann::json& val) {

    if (val.find("status") != val.end()) {
        setStatus(val.at("status"));
    }



    if (val.find("name") != val.end()) {
        setName(val.at("name"));
    }



    if (val.find("address") != val.end()) {
        setAddress(val.at("address"));
    }



    if (val.find("access") != val.end()) {

        if (!val["access"].is_null()) {
            PortsAccessSchema newItem;
            newItem.fromJson(val["access"]);
            setAccess(newItem);
        }

    }

        m_Stp.clear();
    for (auto& item : val["stp"]) {

        PortsStpSchema newItem;
        newItem.fromJson(item);
        m_Stp.push_back(newItem);

    }


    if (val.find("mode") != val.end()) {
        setMode(val.at("mode"));
    }



    if (val.find("trunk") != val.end()) {

        if (!val["trunk"].is_null()) {
            PortsTrunkSchema newItem;
            newItem.fromJson(val["trunk"]);
            setTrunk(newItem);
        }

    }


    if (val.find("peer") != val.end()) {
        setPeer(val.at("peer"));
    }



    if (val.find("uuid") != val.end()) {
        setUuid(val.at("uuid"));
    }


}

nlohmann::json PortsSchema::getKeys() {
    nlohmann::json val = nlohmann::json::object();

    val["name"]["name"] = "name";
    val["name"]["type"] = "key";
    val["name"]["simpletype"] = "string";
    val["name"]["description"] = R"POLYCUBE(Port Name)POLYCUBE";
    val["name"]["example"] = R"POLYCUBE()POLYCUBE";

    return val;
}

nlohmann::json PortsSchema::getElements() {
    nlohmann::json val = nlohmann::json::object();

    val["status"]["name"] = "status";
    val["status"]["type"] = "leaf"; // Suppose that type is leaf
    val["status"]["simpletype"] = "string";
    val["status"]["description"] = R"POLYCUBE(Status of the port (UP or DOWN))POLYCUBE";
    val["status"]["example"] = R"POLYCUBE()POLYCUBE";
    val["status"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Status of the port (UP or DOWN)",
  "enum" : [ "UP", "DOWN" ]
})POLYCUBE");
    val["address"]["name"] = "address";
    val["address"]["type"] = "leaf"; // Suppose that type is leaf
    val["address"]["simpletype"] = "string";
    val["address"]["description"] = R"POLYCUBE(MAC address of the port)POLYCUBE";
    val["address"]["example"] = R"POLYCUBE()POLYCUBE";
    val["address"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "MAC address of the port"
})POLYCUBE");
    val["access"]["name"] = "access";
    val["access"]["type"] = "leaf"; // Suppose that type is leaf
    val["access"]["description"] = R"POLYCUBE()POLYCUBE";
    val["access"]["example"] = R"POLYCUBE()POLYCUBE";
    val["access"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "$ref" : "#/definitions/PortsAccessSchema"
})POLYCUBE");
    val["stp"]["name"] = "stp";
    val["stp"]["type"] = "leaf"; // Suppose that type is leaf
    val["stp"]["type"] = "list";
    val["stp"]["description"] = R"POLYCUBE(Per-vlan Spanning Tree Protocol Port Configuration)POLYCUBE";
    val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
    val["stp"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Per-vlan Spanning Tree Protocol Port Configuration",
  "items" : {
    "$ref" : "#/definitions/PortsStpSchema"
  },
  "x-key" : [ "vlan" ]
})POLYCUBE");
    val["mode"]["name"] = "mode";
    val["mode"]["type"] = "leaf"; // Suppose that type is leaf
    val["mode"]["simpletype"] = "string";
    val["mode"]["description"] = R"POLYCUBE(Type of bridge interface: access/trunk)POLYCUBE";
    val["mode"]["example"] = R"POLYCUBE()POLYCUBE";
    val["mode"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of bridge interface: access/trunk",
  "enum" : [ "access", "trunk" ],
  "default" : "access"
})POLYCUBE");
    val["trunk"]["name"] = "trunk";
    val["trunk"]["type"] = "leaf"; // Suppose that type is leaf
    val["trunk"]["description"] = R"POLYCUBE()POLYCUBE";
    val["trunk"]["example"] = R"POLYCUBE()POLYCUBE";
    val["trunk"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "$ref" : "#/definitions/PortsTrunkSchema"
})POLYCUBE");
    val["peer"]["name"] = "peer";
    val["peer"]["type"] = "leaf"; // Suppose that type is leaf
    val["peer"]["simpletype"] = "string";
    val["peer"]["description"] = R"POLYCUBE(Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2'))POLYCUBE";
    val["peer"]["example"] = R"POLYCUBE()POLYCUBE";
    val["peer"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2')"
})POLYCUBE");
    val["uuid"]["name"] = "uuid";
    val["uuid"]["type"] = "leaf"; // Suppose that type is leaf
    val["uuid"]["simpletype"] = "string";
    val["uuid"]["description"] = R"POLYCUBE(UUID of the port)POLYCUBE";
    val["uuid"]["example"] = R"POLYCUBE()POLYCUBE";
    val["uuid"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "UUID of the port",
  "readOnly" : true
})POLYCUBE");

    return val;
}

nlohmann::json PortsSchema::getWritableLeafs() {
    nlohmann::json val = nlohmann::json::object();

    val["status"]["name"] = "status";
    val["status"]["simpletype"] = "string";
    val["status"]["description"] = R"POLYCUBE(Status of the port (UP or DOWN))POLYCUBE";
    val["status"]["example"] = R"POLYCUBE()POLYCUBE";
    val["status"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Status of the port (UP or DOWN)",
  "enum" : [ "UP", "DOWN" ]
})POLYCUBE");
    val["address"]["name"] = "address";
    val["address"]["simpletype"] = "string";
    val["address"]["description"] = R"POLYCUBE(MAC address of the port)POLYCUBE";
    val["address"]["example"] = R"POLYCUBE()POLYCUBE";
    val["address"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "MAC address of the port"
})POLYCUBE");
    val["mode"]["name"] = "mode";
    val["mode"]["simpletype"] = "string";
    val["mode"]["description"] = R"POLYCUBE(Type of bridge interface: access/trunk)POLYCUBE";
    val["mode"]["example"] = R"POLYCUBE()POLYCUBE";
    val["mode"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of bridge interface: access/trunk",
  "enum" : [ "access", "trunk" ],
  "default" : "access"
})POLYCUBE");
    val["peer"]["name"] = "peer";
    val["peer"]["simpletype"] = "string";
    val["peer"]["description"] = R"POLYCUBE(Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2'))POLYCUBE";
    val["peer"]["example"] = R"POLYCUBE()POLYCUBE";
    val["peer"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2')"
})POLYCUBE");

    return val;
}

nlohmann::json PortsSchema::getComplexElements() {
    nlohmann::json val = nlohmann::json::object();

    val["access"]["name"] = "access";
    val["access"]["type"] = "complex";
    val["access"]["description"] = R"POLYCUBE()POLYCUBE";
    val["access"]["example"] = R"POLYCUBE()POLYCUBE";
    val["stp"]["name"] = "stp";
    val["stp"]["type"] = "list";
    val["stp"]["description"] = R"POLYCUBE(Per-vlan Spanning Tree Protocol Port Configuration)POLYCUBE";
    val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
    val["trunk"]["name"] = "trunk";
    val["trunk"]["type"] = "complex";
    val["trunk"]["description"] = R"POLYCUBE()POLYCUBE";
    val["trunk"]["example"] = R"POLYCUBE()POLYCUBE";

    return val;
}

std::string PortsSchema::getStatus() const {
    return m_Status;
}

void PortsSchema::setStatus(std::string value) {
    m_Status = value;
    m_StatusIsSet = true;
}

bool PortsSchema::statusIsSet() const {
    return m_StatusIsSet;
}

void PortsSchema::unsetStatus() {
    m_StatusIsSet = false;
}
std::string PortsSchema::getName() const {
    return m_Name;
}

void PortsSchema::setName(std::string value) {
    m_Name = value;
    m_NameIsSet = true;
}

bool PortsSchema::nameIsSet() const {
    return m_NameIsSet;
}

void PortsSchema::unsetName() {
    m_NameIsSet = false;
}
std::string PortsSchema::getAddress() const {
    return m_Address;
}

void PortsSchema::setAddress(std::string value) {
    m_Address = value;
    m_AddressIsSet = true;
}

bool PortsSchema::addressIsSet() const {
    return m_AddressIsSet;
}

void PortsSchema::unsetAddress() {
    m_AddressIsSet = false;
}
PortsAccessSchema PortsSchema::getAccess() const {
    return m_Access;
}

void PortsSchema::setAccess(PortsAccessSchema value) {
    m_Access = value;
    m_AccessIsSet = true;
}

bool PortsSchema::accessIsSet() const {
    return m_AccessIsSet;
}

void PortsSchema::unsetAccess() {
    m_AccessIsSet = false;
}
std::vector<PortsStpSchema>& PortsSchema::getStp() {
    return m_Stp;
}


bool PortsSchema::stpIsSet() const {
    return m_StpIsSet;
}

void PortsSchema::unsetStp() {
    m_StpIsSet = false;
}
std::string PortsSchema::getMode() const {
    return m_Mode;
}

void PortsSchema::setMode(std::string value) {
    m_Mode = value;
    m_ModeIsSet = true;
}

bool PortsSchema::modeIsSet() const {
    return m_ModeIsSet;
}

void PortsSchema::unsetMode() {
    m_ModeIsSet = false;
}
PortsTrunkSchema PortsSchema::getTrunk() const {
    return m_Trunk;
}

void PortsSchema::setTrunk(PortsTrunkSchema value) {
    m_Trunk = value;
    m_TrunkIsSet = true;
}

bool PortsSchema::trunkIsSet() const {
    return m_TrunkIsSet;
}

void PortsSchema::unsetTrunk() {
    m_TrunkIsSet = false;
}
std::string PortsSchema::getPeer() const {
    return m_Peer;
}

void PortsSchema::setPeer(std::string value) {
    m_Peer = value;
    m_PeerIsSet = true;
}

bool PortsSchema::peerIsSet() const {
    return m_PeerIsSet;
}

void PortsSchema::unsetPeer() {
    m_PeerIsSet = false;
}
std::string PortsSchema::getUuid() const {
    return m_Uuid;
}

void PortsSchema::setUuid(std::string value) {
    m_Uuid = value;
    m_UuidIsSet = true;
}

bool PortsSchema::uuidIsSet() const {
    return m_UuidIsSet;
}

void PortsSchema::unsetUuid() {
    m_UuidIsSet = false;
}

}
}
}
}

