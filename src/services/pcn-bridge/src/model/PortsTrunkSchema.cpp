/**
* bridge API
* bridge API generated from bridge.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
*/


/* Do not edit this file manually */



#include "PortsTrunkSchema.h"

namespace io {
namespace swagger {
namespace server {
namespace model {

PortsTrunkSchema::PortsTrunkSchema() {
    m_Nativevlan = 0;
    m_NativevlanIsSet = false;
    m_AllowedIsSet = false;

}

PortsTrunkSchema::~PortsTrunkSchema() {}

void PortsTrunkSchema::validate() {
    // TODO: implement validation
}

nlohmann::json PortsTrunkSchema::toJson() const {
    nlohmann::json val = nlohmann::json::object();

    if(m_NativevlanIsSet) {
        val["nativevlan"] = m_Nativevlan;
    }


    {
      nlohmann::json jsonArray;
      for (auto& item : m_Allowed) {
        jsonArray.push_back(ModelBase::toJson(item));
      }

      if (jsonArray.size() > 0) {
        val["allowed"] = jsonArray;
      }
    }


    return val;
}

void PortsTrunkSchema::fromJson(nlohmann::json& val) {

    if (val.find("nativevlan") != val.end()) {
        setNativevlan(val.at("nativevlan"));
    }


        m_Allowed.clear();
    for (auto& item : val["allowed"]) {

        PortsTrunkAllowedSchema newItem;
        newItem.fromJson(item);
        m_Allowed.push_back(newItem);

    }

}

nlohmann::json PortsTrunkSchema::getKeys() {
    nlohmann::json val = nlohmann::json::object();


    return val;
}

nlohmann::json PortsTrunkSchema::getElements() {
    nlohmann::json val = nlohmann::json::object();

    val["nativevlan"]["name"] = "nativevlan";
    val["nativevlan"]["type"] = "leaf"; // Suppose that type is leaf
    val["nativevlan"]["simpletype"] = "integer";
    val["nativevlan"]["description"] = R"POLYCUBE(VLAN that is not tagged in this trunk port)POLYCUBE";
    val["nativevlan"]["example"] = R"POLYCUBE()POLYCUBE";
    val["nativevlan"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "integer",
  "format" : "uint32",
  "description" : "VLAN that is not tagged in this trunk port"
})POLYCUBE");
    val["allowed"]["name"] = "allowed";
    val["allowed"]["type"] = "leaf"; // Suppose that type is leaf
    val["allowed"]["type"] = "list";
    val["allowed"]["description"] = R"POLYCUBE(Allowed vlans)POLYCUBE";
    val["allowed"]["example"] = R"POLYCUBE()POLYCUBE";
    val["allowed"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Allowed vlans",
  "items" : {
    "$ref" : "#/definitions/PortsTrunkAllowedSchema"
  },
  "x-key" : [ "vlanid" ]
})POLYCUBE");

    return val;
}

nlohmann::json PortsTrunkSchema::getWritableLeafs() {
    nlohmann::json val = nlohmann::json::object();

    val["nativevlan"]["name"] = "nativevlan";
    val["nativevlan"]["simpletype"] = "integer";
    val["nativevlan"]["description"] = R"POLYCUBE(VLAN that is not tagged in this trunk port)POLYCUBE";
    val["nativevlan"]["example"] = R"POLYCUBE()POLYCUBE";
    val["nativevlan"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "integer",
  "format" : "uint32",
  "description" : "VLAN that is not tagged in this trunk port"
})POLYCUBE");

    return val;
}

nlohmann::json PortsTrunkSchema::getComplexElements() {
    nlohmann::json val = nlohmann::json::object();

    val["allowed"]["name"] = "allowed";
    val["allowed"]["type"] = "list";
    val["allowed"]["description"] = R"POLYCUBE(Allowed vlans)POLYCUBE";
    val["allowed"]["example"] = R"POLYCUBE()POLYCUBE";

    return val;
}

int32_t PortsTrunkSchema::getNativevlan() const {
    return m_Nativevlan;
}

void PortsTrunkSchema::setNativevlan(int32_t value) {
    m_Nativevlan = value;
    m_NativevlanIsSet = true;
}

bool PortsTrunkSchema::nativevlanIsSet() const {
    return m_NativevlanIsSet;
}

void PortsTrunkSchema::unsetNativevlan() {
    m_NativevlanIsSet = false;
}
std::vector<PortsTrunkAllowedSchema>& PortsTrunkSchema::getAllowed() {
    return m_Allowed;
}


bool PortsTrunkSchema::allowedIsSet() const {
    return m_AllowedIsSet;
}

void PortsTrunkSchema::unsetAllowed() {
    m_AllowedIsSet = false;
}

}
}
}
}

