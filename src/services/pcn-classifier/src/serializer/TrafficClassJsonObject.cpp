/**
* classifier API generated from classifier.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


/* Do not edit this file manually */



#include "TrafficClassJsonObject.h"
#include <regex>

namespace polycube {
namespace service {
namespace model {

TrafficClassJsonObject::TrafficClassJsonObject() {
  m_idIsSet = false;
  m_priorityIsSet = false;
  m_direction = TrafficClassDirectionEnum::BOTH;
  m_directionIsSet = true;
  m_smacIsSet = false;
  m_dmacIsSet = false;
  m_ethtypeIsSet = false;
  m_srcipIsSet = false;
  m_dstipIsSet = false;
  m_l4protoIsSet = false;
  m_sportIsSet = false;
  m_dportIsSet = false;
}

TrafficClassJsonObject::TrafficClassJsonObject(const nlohmann::json &val) :
  JsonObjectBase(val) {
  m_idIsSet = false;
  m_priorityIsSet = false;
  m_directionIsSet = false;
  m_smacIsSet = false;
  m_dmacIsSet = false;
  m_ethtypeIsSet = false;
  m_srcipIsSet = false;
  m_dstipIsSet = false;
  m_l4protoIsSet = false;
  m_sportIsSet = false;
  m_dportIsSet = false;


  if (val.count("id")) {
    setId(val.at("id").get<uint32_t>());
  }

  if (val.count("priority")) {
    setPriority(val.at("priority").get<uint32_t>());
  }

  if (val.count("direction")) {
    setDirection(string_to_TrafficClassDirectionEnum(val.at("direction").get<std::string>()));
  }

  if (val.count("smac")) {
    setSmac(val.at("smac").get<std::string>());
  }

  if (val.count("dmac")) {
    setDmac(val.at("dmac").get<std::string>());
  }

  if (val.count("ethtype")) {
    setEthtype(string_to_TrafficClassEthtypeEnum(val.at("ethtype").get<std::string>()));
  }

  if (val.count("srcip")) {
    setSrcip(val.at("srcip").get<std::string>());
  }

  if (val.count("dstip")) {
    setDstip(val.at("dstip").get<std::string>());
  }

  if (val.count("l4proto")) {
    setL4proto(string_to_TrafficClassL4protoEnum(val.at("l4proto").get<std::string>()));
  }

  if (val.count("sport")) {
    setSport(val.at("sport").get<uint16_t>());
  }

  if (val.count("dport")) {
    setDport(val.at("dport").get<uint16_t>());
  }
}

nlohmann::json TrafficClassJsonObject::toJson() const {
  nlohmann::json val = nlohmann::json::object();
  if (!getBase().is_null()) {
    val.update(getBase());
  }

  if (m_idIsSet) {
    val["id"] = m_id;
  }

  if (m_priorityIsSet) {
    val["priority"] = m_priority;
  }

  if (m_directionIsSet) {
    val["direction"] = TrafficClassDirectionEnum_to_string(m_direction);
  }

  if (m_smacIsSet) {
    val["smac"] = m_smac;
  }

  if (m_dmacIsSet) {
    val["dmac"] = m_dmac;
  }

  if (m_ethtypeIsSet) {
    val["ethtype"] = TrafficClassEthtypeEnum_to_string(m_ethtype);
  }

  if (m_srcipIsSet) {
    val["srcip"] = m_srcip;
  }

  if (m_dstipIsSet) {
    val["dstip"] = m_dstip;
  }

  if (m_l4protoIsSet) {
    val["l4proto"] = TrafficClassL4protoEnum_to_string(m_l4proto);
  }

  if (m_sportIsSet) {
    val["sport"] = m_sport;
  }

  if (m_dportIsSet) {
    val["dport"] = m_dport;
  }

  return val;
}

uint32_t TrafficClassJsonObject::getId() const {
  return m_id;
}

void TrafficClassJsonObject::setId(uint32_t value) {
  m_id = value;
  m_idIsSet = true;
}

bool TrafficClassJsonObject::idIsSet() const {
  return m_idIsSet;
}



uint32_t TrafficClassJsonObject::getPriority() const {
  return m_priority;
}

void TrafficClassJsonObject::setPriority(uint32_t value) {
  m_priority = value;
  m_priorityIsSet = true;
}

bool TrafficClassJsonObject::priorityIsSet() const {
  return m_priorityIsSet;
}



TrafficClassDirectionEnum TrafficClassJsonObject::getDirection() const {
  return m_direction;
}

void TrafficClassJsonObject::setDirection(TrafficClassDirectionEnum value) {
  m_direction = value;
  m_directionIsSet = true;
}

bool TrafficClassJsonObject::directionIsSet() const {
  return m_directionIsSet;
}

void TrafficClassJsonObject::unsetDirection() {
  m_directionIsSet = false;
}

std::string TrafficClassJsonObject::TrafficClassDirectionEnum_to_string(const TrafficClassDirectionEnum &value){
  switch(value) {
    case TrafficClassDirectionEnum::INGRESS:
      return std::string("ingress");
    case TrafficClassDirectionEnum::EGRESS:
      return std::string("egress");
    case TrafficClassDirectionEnum::BOTH:
      return std::string("both");
    default:
      throw std::runtime_error("Bad TrafficClass direction");
  }
}

TrafficClassDirectionEnum TrafficClassJsonObject::string_to_TrafficClassDirectionEnum(const std::string &str){
  if (JsonObjectBase::iequals("ingress", str))
    return TrafficClassDirectionEnum::INGRESS;
  if (JsonObjectBase::iequals("egress", str))
    return TrafficClassDirectionEnum::EGRESS;
  if (JsonObjectBase::iequals("both", str))
    return TrafficClassDirectionEnum::BOTH;
  throw std::runtime_error("TrafficClass direction is invalid");
}
std::string TrafficClassJsonObject::getSmac() const {
  return m_smac;
}

void TrafficClassJsonObject::setSmac(std::string value) {
  m_smac = value;
  m_smacIsSet = true;
}

bool TrafficClassJsonObject::smacIsSet() const {
  return m_smacIsSet;
}

void TrafficClassJsonObject::unsetSmac() {
  m_smacIsSet = false;
}

std::string TrafficClassJsonObject::getDmac() const {
  return m_dmac;
}

void TrafficClassJsonObject::setDmac(std::string value) {
  m_dmac = value;
  m_dmacIsSet = true;
}

bool TrafficClassJsonObject::dmacIsSet() const {
  return m_dmacIsSet;
}

void TrafficClassJsonObject::unsetDmac() {
  m_dmacIsSet = false;
}

TrafficClassEthtypeEnum TrafficClassJsonObject::getEthtype() const {
  return m_ethtype;
}

void TrafficClassJsonObject::setEthtype(TrafficClassEthtypeEnum value) {
  m_ethtype = value;
  m_ethtypeIsSet = true;
}

bool TrafficClassJsonObject::ethtypeIsSet() const {
  return m_ethtypeIsSet;
}

void TrafficClassJsonObject::unsetEthtype() {
  m_ethtypeIsSet = false;
}

std::string TrafficClassJsonObject::TrafficClassEthtypeEnum_to_string(const TrafficClassEthtypeEnum &value){
  switch(value) {
    case TrafficClassEthtypeEnum::ARP:
      return std::string("arp");
    case TrafficClassEthtypeEnum::IP:
      return std::string("ip");
    default:
      throw std::runtime_error("Bad TrafficClass ethtype");
  }
}

TrafficClassEthtypeEnum TrafficClassJsonObject::string_to_TrafficClassEthtypeEnum(const std::string &str){
  if (JsonObjectBase::iequals("arp", str))
    return TrafficClassEthtypeEnum::ARP;
  if (JsonObjectBase::iequals("ip", str))
    return TrafficClassEthtypeEnum::IP;
  throw std::runtime_error("TrafficClass ethtype is invalid");
}
std::string TrafficClassJsonObject::getSrcip() const {
  return m_srcip;
}

void TrafficClassJsonObject::setSrcip(std::string value) {
  m_srcip = value;
  m_srcipIsSet = true;
}

bool TrafficClassJsonObject::srcipIsSet() const {
  return m_srcipIsSet;
}

void TrafficClassJsonObject::unsetSrcip() {
  m_srcipIsSet = false;
}

std::string TrafficClassJsonObject::getDstip() const {
  return m_dstip;
}

void TrafficClassJsonObject::setDstip(std::string value) {
  m_dstip = value;
  m_dstipIsSet = true;
}

bool TrafficClassJsonObject::dstipIsSet() const {
  return m_dstipIsSet;
}

void TrafficClassJsonObject::unsetDstip() {
  m_dstipIsSet = false;
}

TrafficClassL4protoEnum TrafficClassJsonObject::getL4proto() const {
  return m_l4proto;
}

void TrafficClassJsonObject::setL4proto(TrafficClassL4protoEnum value) {
  m_l4proto = value;
  m_l4protoIsSet = true;
}

bool TrafficClassJsonObject::l4protoIsSet() const {
  return m_l4protoIsSet;
}

void TrafficClassJsonObject::unsetL4proto() {
  m_l4protoIsSet = false;
}

std::string TrafficClassJsonObject::TrafficClassL4protoEnum_to_string(const TrafficClassL4protoEnum &value){
  switch(value) {
    case TrafficClassL4protoEnum::ICMP:
      return std::string("icmp");
    case TrafficClassL4protoEnum::TCP:
      return std::string("tcp");
    case TrafficClassL4protoEnum::UDP:
      return std::string("udp");
    default:
      throw std::runtime_error("Bad TrafficClass l4proto");
  }
}

TrafficClassL4protoEnum TrafficClassJsonObject::string_to_TrafficClassL4protoEnum(const std::string &str){
  if (JsonObjectBase::iequals("icmp", str))
    return TrafficClassL4protoEnum::ICMP;
  if (JsonObjectBase::iequals("tcp", str))
    return TrafficClassL4protoEnum::TCP;
  if (JsonObjectBase::iequals("udp", str))
    return TrafficClassL4protoEnum::UDP;
  throw std::runtime_error("TrafficClass l4proto is invalid");
}
uint16_t TrafficClassJsonObject::getSport() const {
  return m_sport;
}

void TrafficClassJsonObject::setSport(uint16_t value) {
  m_sport = value;
  m_sportIsSet = true;
}

bool TrafficClassJsonObject::sportIsSet() const {
  return m_sportIsSet;
}

void TrafficClassJsonObject::unsetSport() {
  m_sportIsSet = false;
}

uint16_t TrafficClassJsonObject::getDport() const {
  return m_dport;
}

void TrafficClassJsonObject::setDport(uint16_t value) {
  m_dport = value;
  m_dportIsSet = true;
}

bool TrafficClassJsonObject::dportIsSet() const {
  return m_dportIsSet;
}

void TrafficClassJsonObject::unsetDport() {
  m_dportIsSet = false;
}


}
}
}

