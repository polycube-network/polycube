/**
* firewall API generated from firewall.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


/* Do not edit this file manually */



#include "ChainBatchInputRulesJsonObject.h"
#include <regex>

namespace polycube {
namespace service {
namespace model {

ChainBatchInputRulesJsonObject::ChainBatchInputRulesJsonObject() {
  m_idIsSet = false;
  m_operationIsSet = false;
  m_srcIsSet = false;
  m_dstIsSet = false;
  m_l4protoIsSet = false;
  m_sportIsSet = false;
  m_dportIsSet = false;
  m_tcpflagsIsSet = false;
  m_conntrackIsSet = false;
  m_actionIsSet = false;
  m_descriptionIsSet = false;
}

ChainBatchInputRulesJsonObject::ChainBatchInputRulesJsonObject(const nlohmann::json &val) :
    JsonObjectBase(val) {
  m_idIsSet = false;
  m_operationIsSet = false;
  m_srcIsSet = false;
  m_dstIsSet = false;
  m_l4protoIsSet = false;
  m_sportIsSet = false;
  m_dportIsSet = false;
  m_tcpflagsIsSet = false;
  m_conntrackIsSet = false;
  m_actionIsSet = false;
  m_descriptionIsSet = false;


  if (val.count("id")) {
    setId(val.at("id").get<uint32_t>());
  }

  if (val.count("operation")) {
    setOperation(string_to_OperationEnum(val.at("operation").get<std::string>()));
  }

  if (val.count("src")) {
    setSrc(val.at("src").get<std::string>());
  }

  if (val.count("dst")) {
    setDst(val.at("dst").get<std::string>());
  }

  if (val.count("l4proto")) {
    setL4proto(val.at("l4proto").get<std::string>());
  }

  if (val.count("sport")) {
    setSport(val.at("sport").get<uint16_t>());
  }

  if (val.count("dport")) {
    setDport(val.at("dport").get<uint16_t>());
  }

  if (val.count("tcpflags")) {
    setTcpflags(val.at("tcpflags").get<std::string>());
  }

  if (val.count("conntrack")) {
    setConntrack(string_to_ConntrackstatusEnum(val.at("conntrack").get<std::string>()));
  }

  if (val.count("action")) {
    setAction(string_to_ActionEnum(val.at("action").get<std::string>()));
  }

  if (val.count("description")) {
    setDescription(val.at("description").get<std::string>());
  }
}

nlohmann::json ChainBatchInputRulesJsonObject::toJson() const {
  nlohmann::json val = nlohmann::json::object();
  if (!getBase().is_null()) {
    val.update(getBase());
  }

  if (m_idIsSet) {
    val["id"] = m_id;
  }

  if (m_operationIsSet) {
    val["operation"] = OperationEnum_to_string(m_operation);
  }

  if (m_srcIsSet) {
    val["src"] = m_src;
  }

  if (m_dstIsSet) {
    val["dst"] = m_dst;
  }

  if (m_l4protoIsSet) {
    val["l4proto"] = m_l4proto;
  }

  if (m_sportIsSet) {
    val["sport"] = m_sport;
  }

  if (m_dportIsSet) {
    val["dport"] = m_dport;
  }

  if (m_tcpflagsIsSet) {
    val["tcpflags"] = m_tcpflags;
  }

  if (m_conntrackIsSet) {
    val["conntrack"] = ConntrackstatusEnum_to_string(m_conntrack);
  }

  if (m_actionIsSet) {
    val["action"] = ActionEnum_to_string(m_action);
  }

  if (m_descriptionIsSet) {
    val["description"] = m_description;
  }

  return val;
}

uint32_t ChainBatchInputRulesJsonObject::getId() const {
  return m_id;
}

void ChainBatchInputRulesJsonObject::setId(uint32_t value) {
  m_id = value;
  m_idIsSet = true;
}

bool ChainBatchInputRulesJsonObject::idIsSet() const {
  return m_idIsSet;
}



OperationEnum ChainBatchInputRulesJsonObject::getOperation() const {
  return m_operation;
}

void ChainBatchInputRulesJsonObject::setOperation(OperationEnum value) {
  m_operation = value;
  m_operationIsSet = true;
}

bool ChainBatchInputRulesJsonObject::operationIsSet() const {
  return m_operationIsSet;
}

void ChainBatchInputRulesJsonObject::unsetOperation() {
  m_operationIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::OperationEnum_to_string(const OperationEnum &value){
  switch(value) {
  case OperationEnum::INSERT:
    return std::string("insert");
  case OperationEnum::APPEND:
    return std::string("append");
  case OperationEnum::DELETE:
    return std::string("delete");
  case OperationEnum::UPDATE:
    return std::string("update");
  default:
    throw std::runtime_error("Bad ChainBatchInputRules operation");
  }
}

OperationEnum ChainBatchInputRulesJsonObject::string_to_OperationEnum(const std::string &str){
  if (JsonObjectBase::iequals("insert", str))
    return OperationEnum::INSERT;
  if (JsonObjectBase::iequals("append", str))
    return OperationEnum::APPEND;
  if (JsonObjectBase::iequals("delete", str))
    return OperationEnum::DELETE;
  if (JsonObjectBase::iequals("update", str))
    return OperationEnum::UPDATE;
  throw std::runtime_error("ChainBatchInputRules operation is invalid");
}
std::string ChainBatchInputRulesJsonObject::getSrc() const {
  return m_src;
}

void ChainBatchInputRulesJsonObject::setSrc(std::string value) {
  m_src = value;
  m_srcIsSet = true;
}

bool ChainBatchInputRulesJsonObject::srcIsSet() const {
  return m_srcIsSet;
}

void ChainBatchInputRulesJsonObject::unsetSrc() {
  m_srcIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::getDst() const {
  return m_dst;
}

void ChainBatchInputRulesJsonObject::setDst(std::string value) {
  m_dst = value;
  m_dstIsSet = true;
}

bool ChainBatchInputRulesJsonObject::dstIsSet() const {
  return m_dstIsSet;
}

void ChainBatchInputRulesJsonObject::unsetDst() {
  m_dstIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::getL4proto() const {
  return m_l4proto;
}

void ChainBatchInputRulesJsonObject::setL4proto(std::string value) {
  m_l4proto = value;
  m_l4protoIsSet = true;
}

bool ChainBatchInputRulesJsonObject::l4protoIsSet() const {
  return m_l4protoIsSet;
}

void ChainBatchInputRulesJsonObject::unsetL4proto() {
  m_l4protoIsSet = false;
}

uint16_t ChainBatchInputRulesJsonObject::getSport() const {
  return m_sport;
}

void ChainBatchInputRulesJsonObject::setSport(uint16_t value) {
  m_sport = value;
  m_sportIsSet = true;
}

bool ChainBatchInputRulesJsonObject::sportIsSet() const {
  return m_sportIsSet;
}

void ChainBatchInputRulesJsonObject::unsetSport() {
  m_sportIsSet = false;
}

uint16_t ChainBatchInputRulesJsonObject::getDport() const {
  return m_dport;
}

void ChainBatchInputRulesJsonObject::setDport(uint16_t value) {
  m_dport = value;
  m_dportIsSet = true;
}

bool ChainBatchInputRulesJsonObject::dportIsSet() const {
  return m_dportIsSet;
}

void ChainBatchInputRulesJsonObject::unsetDport() {
  m_dportIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::getTcpflags() const {
  return m_tcpflags;
}

void ChainBatchInputRulesJsonObject::setTcpflags(std::string value) {
  m_tcpflags = value;
  m_tcpflagsIsSet = true;
}

bool ChainBatchInputRulesJsonObject::tcpflagsIsSet() const {
  return m_tcpflagsIsSet;
}

void ChainBatchInputRulesJsonObject::unsetTcpflags() {
  m_tcpflagsIsSet = false;
}

ConntrackstatusEnum ChainBatchInputRulesJsonObject::getConntrack() const {
  return m_conntrack;
}

void ChainBatchInputRulesJsonObject::setConntrack(ConntrackstatusEnum value) {
  m_conntrack = value;
  m_conntrackIsSet = true;
}

bool ChainBatchInputRulesJsonObject::conntrackIsSet() const {
  return m_conntrackIsSet;
}

void ChainBatchInputRulesJsonObject::unsetConntrack() {
  m_conntrackIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::ConntrackstatusEnum_to_string(const ConntrackstatusEnum &value){
  switch(value) {
  case ConntrackstatusEnum::NEW:
    return std::string("new");
  case ConntrackstatusEnum::ESTABLISHED:
    return std::string("established");
  case ConntrackstatusEnum::RELATED:
    return std::string("related");
  case ConntrackstatusEnum::INVALID:
    return std::string("invalid");
  default:
    throw std::runtime_error("Bad ChainBatchInputRules conntrack");
  }
}

ConntrackstatusEnum ChainBatchInputRulesJsonObject::string_to_ConntrackstatusEnum(const std::string &str){
  if (JsonObjectBase::iequals("new", str))
    return ConntrackstatusEnum::NEW;
  if (JsonObjectBase::iequals("established", str))
    return ConntrackstatusEnum::ESTABLISHED;
  if (JsonObjectBase::iequals("related", str))
    return ConntrackstatusEnum::RELATED;
  if (JsonObjectBase::iequals("invalid", str))
    return ConntrackstatusEnum::INVALID;
  throw std::runtime_error("ChainBatchInputRules conntrack is invalid");
}
ActionEnum ChainBatchInputRulesJsonObject::getAction() const {
  return m_action;
}

void ChainBatchInputRulesJsonObject::setAction(ActionEnum value) {
  m_action = value;
  m_actionIsSet = true;
}

bool ChainBatchInputRulesJsonObject::actionIsSet() const {
  return m_actionIsSet;
}

void ChainBatchInputRulesJsonObject::unsetAction() {
  m_actionIsSet = false;
}

std::string ChainBatchInputRulesJsonObject::ActionEnum_to_string(const ActionEnum &value){
  switch(value) {
  case ActionEnum::DROP:
    return std::string("drop");
  case ActionEnum::LOG:
    return std::string("log");
  case ActionEnum::FORWARD:
    return std::string("forward");
  default:
    throw std::runtime_error("Bad ChainBatchInputRules action");
  }
}

ActionEnum ChainBatchInputRulesJsonObject::string_to_ActionEnum(const std::string &str){
  if (JsonObjectBase::iequals("drop", str))
    return ActionEnum::DROP;
  if (JsonObjectBase::iequals("log", str))
    return ActionEnum::LOG;
  if (JsonObjectBase::iequals("forward", str))
    return ActionEnum::FORWARD;
  throw std::runtime_error("ChainBatchInputRules action is invalid");
}
std::string ChainBatchInputRulesJsonObject::getDescription() const {
  return m_description;
}

void ChainBatchInputRulesJsonObject::setDescription(std::string value) {
  m_description = value;
  m_descriptionIsSet = true;
}

bool ChainBatchInputRulesJsonObject::descriptionIsSet() const {
  return m_descriptionIsSet;
}

void ChainBatchInputRulesJsonObject::unsetDescription() {
  m_descriptionIsSet = false;
}


}
}
}

