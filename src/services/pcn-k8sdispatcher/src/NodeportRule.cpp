/**
* k8sdispatcher API generated from k8sdispatcher.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/

#include "NodeportRule.h"
#include "K8sdispatcher.h"


NodeportRule::NodeportRule(K8sdispatcher &parent, const NodeportRuleJsonObject &conf)
        : NodeportRuleBase(parent), parent_(parent) {
    logger()->info("creating NodeportRule instance");
    this->nodeportName_ = conf.nodeportNameIsSet() ? conf.getNodeportName() : "";
    this->nodeportPort_ = conf.getNodeportPort();
    this->proto_ = conf.getProto();
    this->serviceType_ = conf.serviceTypeIsSet() ? conf.getServiceType() : NodeportRuleServiceTypeEnum::CLUSTER;
    logger()->info("created NodeportRule instance");
}

NodeportRule::~NodeportRule() {}

void NodeportRule::update(const NodeportRuleJsonObject &conf) {
    if (conf.nodeportNameIsSet()) {
        setNodeportName(conf.getNodeportName());
    }
    if (conf.serviceTypeIsSet()) {
        setServiceType(conf.getServiceType());
    }
}

NodeportRuleJsonObject NodeportRule::toJsonObject() {
    NodeportRuleJsonObject conf;
    try {
        conf.setNodeportName(getNodeportName());
        conf.setNodeportPort(getNodeportPort());
        conf.setProto(getProto());
        conf.setServiceType(getServiceType());
    } catch (std::exception& ex) {
        logger()->warn("NodeportRule::toJsonObject exception: {}", ex.what());
    }

    return conf;
}

std::string NodeportRule::getNodeportName() {
    return this->nodeportName_;
}

void NodeportRule::setNodeportName(const std::string &value) {
    logger()->info("received a request to update NodePort rule's name");
    this->nodeportName_ = value;
    logger()->info("updated NodePort rule's service name");
}

uint16_t NodeportRule::getNodeportPort() {
    return this->nodeportPort_;
}

std::string NodeportRule::getProto() {
    return this->proto_;
}

NodeportRuleServiceTypeEnum NodeportRule::getServiceType() {
    return this->serviceType_;
}

void NodeportRule::setServiceType(const NodeportRuleServiceTypeEnum &value) {
    logger()->info("received a request to update NodePort rule's service type");
    try {
        logger()->trace("retrieving NodePort rules kernel map");
        auto dp_rules = this->parent_.get_hash_table<dp_k, dp_v>(K8sdispatcher::EBPF_DP_RULES_MAP);
        logger()->trace("retrieved NodePort rules kernel map");

        dp_k dp_key{
                .dummy = 56,
                .external_port = htons(this->nodeportPort_),
                .proto = K8sdispatcher::protoStrToInt(this->proto_),
        };
        dp_v dp_value{
                .internal_port = htons(this->nodeportPort_),
                .entry_type = K8sdispatcher::serviceTypeToInt(value),
        };

        logger()->trace("updating NodePort rule's service type in NodePort rules kernel map");
        dp_rules.set(dp_key, dp_value);
        this->serviceType_ = value;
        logger()->trace("updated NodePort rule's service type in NodePort rules kernel map");
    }
    catch (std::exception &ex) {
        logger()->error("failed to update NodePort rule's in kernel map: {}", ex.what());
        throw std::runtime_error("failed to store NodePort rule's in kernel map");
    }
    logger()->info("updated NodePort rule's service type");
}


